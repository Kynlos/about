---
title: The road to 4.0 
description: TODO
authors:
  - name: Beyang Liu
    url: 
publishDate: 2022-09-27T00:00
tags: [blog]
slug: journey-to-four-oh
published: flase
<!-- heroImage: https://storage.googleapis.com/sourcegraph-assets/blog/jetbrains-plugin/jetbrains-announcement-hero.png -->
<!-- socialImage: https://storage.googleapis.com/sourcegraph-assets/blog/jetbrains-plugin/jetbrains-announcement-hero.png -->
---

Last week Sourcegraph turned 4.0. It's been a fantastic journey since we started the company back in 2013, and it seems an appropriate time to take stock of the road behind us and the road ahead. What was the path from serving zero to over one million devs, and what does the road look like ahead to serving many millions more?

<figure>
<img src="https://user-images.githubusercontent.com/1646931/185644353-62d2298e-ede3-4bb6-a072-d77fc0650abe.png" style={{maxWidth: "500px"}}/>
<center><figcaption>Quinn and me at FOSDEM 2014, a few months after starting Sourcegraph</figcaption></center>
</figure>

### Genesis

For me, there was no single "eureka" moment. Looking back, you can sort of connect some dots.

One of the catalysts was my first programming job out of school.
On the first day, I was handed an app that had passed through five owners over the previous year. The code was not in a great state. Each seemingly simple fix involved a long string of why's, what's—and [wat](https://www.destroyallsoftware.com/talks/wat)'s.

A month into the job, I'd made only a handful of minor fixes. I was meeting expectations, but something felt off.
What got me into programming was a certain *feeling* that I think most devs can relate to. It's the feeling of solving logic puzzles to build something cool, the feeling when you hit enter and the machine comes to life, the feeling you get to experience when you're slinging code at the speed of thought.
Here I was, at the start of my professional programming career, and I'd gone an entire month without experiencing that feeling.

I'd spent nearly all my time trying to understand existing code. And it dawned on me that most of my job was not writing code, but reading it. The problem was that reading code was a lot less fun than writing it!

A couple years later, I caught up with my co-founder, Quinn, and we got to reflecting on our journeys as programmers, and we discovered a mutual yearning for those magical moments when you get to experience *the feeling*. It was not lost on us that this feeling tends to coincide with 10x productivity and that programmer productivity increasingly drives overall technological progress.

Sourcegraph crystallized around those discussions. Code search was a starting point of inspiration for both of us, Quinn having spun up OpenGrok while contributing to open source and I having used code search inside Google. We both realized that search was a versatile tool that could make large codebases tractable by making the winding, forking path of understanding code more fun and straightforward.

But we also dreamt beyond code search of a big intelligent system that had the brain of the most advanced semantic analyzers but awareness of all the code in the world.
It would be a global graph that contained every symbol and reference in the world, that pulled in context from many different compile-time and run-time systems and overlaid this information with precision into every place humans interacted with source.

We wanted to build something that would democratize code understanding and make exploring codebases, no matter how big or how numerous the dependencies, as easy as surfing the web.

### Early iterations

Being over-confident engineers, we estimated it would take us about 3 to 4 months to build this system. What was the MVP of Sourcegraph like?

<figure>
<img src="https://user-images.githubusercontent.com/1646931/185650505-1c613fc4-4086-4c51-93e6-f630330bef39.png" style={{border: "1px solid lightgray"}}/>
<center><figcaption>An early iteration of Sourcegraph</figcaption></center>
</figure>

The first release of Sourcegraph was an Angular app. You could search for symbols, jump to definition, and find references in a few languages. Before the world had heard of LSP, we created [srclib](https://srclib.org) to genericize the implementation of code intelligence across different languages. We knew we were onto something when we started using it ourselves and saved a lot of time as we explored and reused open-source libraries.

The next iteration of Sourcegraph, which I'll retroactively label "v1", was a server-side rendered Go web app with minimal JS. We had some pains around initial page load time and thought the ideal "form factor" was more of a snappy content site.

Sourcegraph "2" pivoted back to a rich web application, this time with React and TypeScript. As we acquired more users, it become apparent that a richer UI would, in fact, be beneficial, but we continued to prioritize speed and snappiness as first-class features. We adopted a multi-service architecture for scale, deployed via Kubernetes or a single Docker container.

### Inflection point

In February of 2019, we announced [Sourcegraph 3.0](https://about.sourcegraph.com/blog/sourcegraph-3.0) and open-sourced our core code.
Then things really picked up. The open-core model enabled us to address security concerns and earn developer trust, and the single Docker container enabled any dev to spin up an instance on their local machine, add some private code, and see Sourcegraph in action.

<figure>
<img src="https://about.sourcegraph.com/blog/announcing-sourcegraph-3.0/basic_code_intel.png"/>
<center><figcaption>A screenshot from the 3.0 release</figcaption></center>
</figure>

We adopted a layered approach to code navigation that allowed us to support a much wider set of languages.
We supported repository permissions for all major code hosts, something that was critical for enterprises.

Since 3.0, we've shipped many things.

* **Batch Changes** for making big code changes arose out of listening to our customers undertaking big refactors to improve security, code quality, and code reuse
* **Code Insights** to turn any such query into a timeseries graph, embeddable in a dashboard, often used to track patterns and anti-patterns, like adoption of new APIs or accidentally committed secrets, over time.
* **Code Monitors** to alert on those patterns and anti-patterns.
* **Notebooks** to record and transform your code exploration notes into a rich, shareable Markdown docs with embeddable queries and code snippets.
* **A rich query language** that encompasses much more than regex—a plethora of filters and selectors searching over raw code, symbols, diffs, and metadata, along with support for the Comby syntax that makes matching common code patterns far more ergonomic than regex.
* **Precise code navigation** for Go, TypeScript, JavaScript, C++, Java, Scala, Kotlin, and Python, which improves upon the baseline we've established for code navigation in every language.
* **Scalability** to the largest private codebases in the world and over 3 million open-source repositories, including nearly every GitHub repository with more than 5 stars, major projects on GitLab and independent repositories, and code in package hosts like NPM, PyPI, and Maven Central.

Along the way, we became more than "just code search." By listening to our users and customers, we expanded our value proposition to tackle some of the hardest challenges around code understanding for both individual devs and engineering leaders. Sourcegraph today is a bit hard to categorize—it's not a code host or an editor or a build service, though it has elements of all of these and helps with things like reading, writing, reviewing, and validating code.

<figure>
<img src="https://user-images.githubusercontent.com/1646931/185812081-0769583e-66f1-44fe-8e8d-126f07222a9b.png"/>
<center><figcaption>A graphic we created to describe what Sourcegraph was to devs who've never encountered it</figcaption></center>
</figure>

Because it was so hard to categorize, we invented a category to place ourselves in, something we call a "Code Intelligence Platform".

It's one thing to list out what the properties of a Code Intelligence Platform are, but like most devs, I prefer to "show, not tell."

### Sourcegraph today

Here's a whirlwind tour of some of the coolest things you can do in Sourcegraph today.

#### Table stakes: find string literals and regexes, universally

Though most code hosts still lack this functionality, string literal and regular expression search have long been core features of code search engines like OpenGrok and Hound. Sourcegraph scales these to the needs of modern software development. You can search for string literals and regexes across millions of repositories and as many code hosts as you have (GitHub, GitLab, Bitbucket, anything with a clone URL). You can also search over code in different version control systems (Git, Perforce, SVN, CVS) and package repositories (npm, PyPI, Maven, crates.io).

A few examples:

* [(First gif) Locate the source of the error message, "At least one model must be passed to register"](https://sourcegraph.com/search?q=context:global+At+least+one+model+must+be+passed+to+register&patternType=lucky)
* [Locate the same error message, but restricted to PyPI packages](https://sourcegraph.com/search?q=context:global+repo:%5Epython/+At+least+one+model+must+be+passed+to+register&patternType=lucky)
* [Locate the source of a parameterized error message](https://sourcegraph.com/search?q=context:global+server+reported+code:+.%2B%2C+message:+.%2B&patternType=regexp)
* [(Second gif) Search your repositories for secrets like private API keys or secrets accidentally committed](https://sourcegraph.com/search/console?q=repo%3A%5Egithub.com%2F%0A%0A%2F%2F%20Filter%20out%20any%20files%20you%20don%27t%20want%0A-file%3A(index.html%7Csourcegraph-console-query.txt%7CREADME.md%7Cbookmarklet.js)%0A%0Apatterntype%3Aregexp%0Acase%3Ayes%20%0A%0A%2F%2F%20Use%20this%20list%20of%20known%20patterns%20(from%20truffleHog)%20and%20add%20your%20own!%0A%2F%2F%20Slack%20Token%0A(xox%5Bpborsa%5D-%5B0-9%5D%7B12%7D-%5B0-9%5D%7B12%7D-%5B0-9%5D%7B12%7D-%5Ba-z0-9%5D%7B32%7D)%20or%0A%0A%2F%2F%20RSA%20private%20key%0A-----BEGIN%20RSA%20PRIVATE%20KEY-----%20or%0A%0A%2F%2F%20SSH%20(DSA)%20private%20key%0A-----BEGIN%20DSA%20PRIVATE%20KEY-----%20or%0A%0A%2F%2F%20SSH%20(EC)%20private%20key%0A-----BEGIN%20EC%20PRIVATE%20KEY-----%20or%0A%0A%2F%2F%20PGP%20private%20key%20block%0A-----BEGIN%20PGP%20PRIVATE%20KEY%20BLOCK-----%20or%0A%0A%2F%2F%20AWS%20API%20Key%0A((%3F%3AA3T%5BA-Z0-9%5D%7CAKIA%7CAGPA%7CAIDA%7CAROA%7CAIPA%7CANPA%7CANVA%7CASIA)%5BA-Z0-9%5D%7B16%7D)%20or%0A%0A%2F%2F%20Amazon%20MWS%20Auth%20Token%0Aamzn%5C%5C.mws%5C%5C.%5B0-9a-f%5D%7B8%7D-%5B0-9a-f%5D%7B4%7D-%5B0-9a-f%5D%7B4%7D-%5B0-9a-f%5D%7B4%7D-%5B0-9a-f%5D%7B12%7D%20or%0A%0A%2F%2F%20AWS%20API%20Key%0AAKIA%5B0-9A-Z%5D%7B16%7D%20or%0A%0A%2F%2F%20AWS%20AppSync%20GraphQL%20Key%0Ada2-%5Ba-z0-9%5D%7B26%7D%20or%0A%0A%2F%2F%20Facebook%20Access%20Token%0AEAACEdEose0cBA%5B0-9A-Za-z%5D%2B%20or%0A%0A%2F%2F%20Facebook%20OAuth%0A%5BfF%5D%5BaA%5D%5BcC%5D%5BeE%5D%5BbB%5D%5BoO%5D%5BoO%5D%5BkK%5D.*%5B%27%7C%5C%22%5D%5B0-9a-f%5D%7B32%7D%5B%27%7C%5C%22%5D%20or%0A%0A%2F%2F%20GitHub%0A%5BgG%5D%5BiI%5D%5BtT%5D%5BhH%5D%5BuU%5D%5BbB%5D.*%5B%27%7C%5C%22%5D%5B0-9a-zA-Z%5D%7B35%2C40%7D%5B%27%7C%5C%22%5D%20or%0A%0A%2F%2F%20Generic%20API%20Key%0A%5BaA%5D%5BpP%5D%5BiI%5D_%3F%5BkK%5D%5BeE%5D%5ByY%5D.*%5B%27%7C%5C%22%5D%5B0-9a-zA-Z%5D%7B32%2C45%7D%5B%27%7C%5C%22%5D%20or%0A%0A%2F%2F%20Generic%20Secret%0A%5BsS%5D%5BeE%5D%5BcC%5D%5BrR%5D%5BeE%5D%5BtT%5D.*%5B%27%7C%5C%22%5D%5B0-9a-zA-Z%5D%7B32%2C45%7D%5B%27%7C%5C%22%5D%20or%0A%0A%2F%2F%20Google%20API%20Key%0AAIza%5B0-9A-Za-z%5C%5C-_%5D%7B35%7D%20or%0A%0A%2F%2F%20Google%20Cloud%20Platform%20API%20Key%0AAIza%5B0-9A-Za-z%5C%5C-_%5D%7B35%7D%20or%0A%0A%2F%2F%20Google%20Cloud%20Platform%20OAuth%0A%5B0-9%5D%2B-%5B0-9A-Za-z_%5D%7B32%7D%5C%5C.apps%5C%5C.googleusercontent%5C%5C.com%20or%0A%0A%2F%2F%20Google%20Drive%20API%20Key%0AAIza%5B0-9A-Za-z%5C%5C-_%5D%7B35%7D%20or%0A%0A%2F%2F%20Google%20Drive%20OAuth%0A%5B0-9%5D%2B-%5B0-9A-Za-z_%5D%7B32%7D%5C%5C.apps%5C%5C.googleusercontent%5C%5C.com%20or%0A%0A%2F%2F%20Google%20(GCP)%20Service-account%0A%5C%22type%5C%22%3A%20%5C%22service_account%5C%22%20or%0A%0A%2F%2F%20Google%20Gmail%20API%20Key%0AAIza%5B0-9A-Za-z%5C%5C-_%5D%7B35%7D%20or%0A%0A%2F%2F%20Google%20Gmail%20OAuth%0A%5B0-9%5D%2B-%5B0-9A-Za-z_%5D%7B32%7D%5C%5C.apps%5C%5C.googleusercontent%5C%5C.com%20or%0A%0A%2F%2F%20Google%20OAuth%20Access%20Token%0Aya29%5C%5C.%5B0-9A-Za-z%5C%5C-_%5D%2B%20or%0A%0A%2F%2F%20Google%20YouTube%20API%20Key%0AAIza%5B0-9A-Za-z%5C%5C-_%5D%7B35%7D%20or%0A%0A%2F%2F%20Google%20YouTube%20OAuth%0A%5B0-9%5D%2B-%5B0-9A-Za-z_%5D%7B32%7D%5C%5C.apps%5C%5C.googleusercontent%5C%5C.com%20or%0A%0A%2F%2F%20Heroku%20API%20Key%0A%5BhH%5D%5BeE%5D%5BrR%5D%5BoO%5D%5BkK%5D%5BuU%5D.*%5B0-9A-F%5D%7B8%7D-%5B0-9A-F%5D%7B4%7D-%5B0-9A-F%5D%7B4%7D-%5B0-9A-F%5D%7B4%7D-%5B0-9A-F%5D%7B12%7D%20or%0A%0A%2F%2F%20Mailchimp%20API%20Key%0A%5B0-9a-f%5D%7B32%7D-us%5B0-9%5D%7B1%2C2%7D%20or%0A%0A%2F%2F%20Mailgun%20API%20Key%0Akey-%5B0-9a-zA-Z%5D%7B32%7D%20or%0A%0A%2F%2F%20Password%20in%20URL%0A%5Ba-zA-Z%5D%7B3%2C10%7D%3A%2F%2F%20%5B%5E%2F%5C%5Cs%3A%40%5D%7B3%2C20%7D%3A%5B%5E%2F%5C%5Cs%3A%40%5D%7B3%2C20%7D%40.%7B1%2C100%7D%5B%5C%22%27%5C%5Cs%5D%20or%0A%0A%2F%2F%20PayPal%20Braintree%20Access%20Token%0Aaccess_token%5C%5C%24production%5C%5C%24%5B0-9a-z%5D%7B16%7D%5C%5C%24%5B0-9a-f%5D%7B32%7D%20or%0A%0A%2F%2F%20Picatic%20API%20Key%0Ask_live_%5B0-9a-z%5D%7B32%7D%20or%0A%0A%2F%2F%20Slack%20Webhook%0Ahttps%3A%2F%2F%20hooks%5C%5C.slack%5C%5C.com%2Fservices%2FT%5Ba-zA-Z0-9_%5D%7B8%7D%2FB%5Ba-zA-Z0-9_%5D%7B8%7D%2F%5Ba-zA-Z0-9_%5D%7B24%7D%20or%0A%0A%2F%2F%20Stripe%20API%20Key%0Ask_live_%5B0-9a-zA-Z%5D%7B24%7D%20or%0A%0A%2F%2F%20Stripe%20Restricted%20API%20Key%0Ark_live_%5B0-9a-zA-Z%5D%7B24%7D%20or%0A%0A%2F%2F%20Square%20Access%20Token%0Asq0atp-%5B0-9A-Za-z%5C%5C-_%5D%7B22%7D%20or%0A%0A%2F%2F%20Square%20OAuth%20Secret%0Asq0csp-%5B0-9A-Za-z%5C%5C-_%5D%7B43%7D%20or%0A%0A%2F%2F%20Telegram%20Bot%20API%20Key%0A%5B0-9%5D%2B%3AAA%5B0-9A-Za-z%5C%5C-_%5D%7B33%7D%20or%0A%0A%2F%2F%20Twilio%20API%20Key%0ASK%5B0-9a-fA-F%5D%7B32%7D%20or%0A%0A%2F%2F%20Twitter%20Access%20Token%0A%5BtT%5D%5BwW%5D%5BiI%5D%5BtT%5D%5BtT%5D%5BeE%5D%5BrR%5D.*%5B1-9%5D%5B0-9%5D%2B-%5B0-9a-zA-Z%5D%7B40%7D%20or%0A%0A%2F%2F%20Twitter%20OAuth%0A%5BtT%5D%5BwW%5D%5BiI%5D%5BtT%5D%5BtT%5D%5BeE%5D%5BrR%5D.*%5B%27%7C%5C%22%5D%5B0-9a-zA-Z%5D%7B35%2C44%7D%5B%27%7C%5C%22%5D%22%0A%0A%2F%2F%20Not%20from%20truffleHog%0A%0A%2F%2F%20Twitter%20Secret%0A%5B0-9a-zA-Z%5D%7B50%7D%0A%0A%2F%2F%20Twitter%20Bearer%20Token%0AA%7B22%7D%5B0-9a-zA-Z%5D.%7B89%7D%0A%0A%2F%2F%20GitHub%20Token%0Aghp_%5B0-9a-z%5D%7B36%7D)

![](https://user-images.githubusercontent.com/1646931/184545600-37028f32-7c48-4bb1-9c9f-b37fa05019cf.gif)

![](https://user-images.githubusercontent.com/1646931/184546102-f8c794e6-629f-4df8-8975-ebae29e4e4de.gif)

#### Find functions, packages, and other symbols by keyword

IDEs often have language awareness and allow the user to search through functions in your local code by name. Sourcegraph brings IDE-like language awareness to a much wider range of code. You can locate symbols across your company (subject to ACLs) or across the open-source universe. You can filter for a specific symbol type, such as function, method, class, or package.

TODO: gif showing select. syntax

Examples:

* If you need to implement some auth middleware for your web app, search for [`auth middleware func`](https://sourcegraph.sourcegraph.com/search?q=context:global+auth+middleware+func&patternType=lucky)
* If you want to find how to listen for HTTP connections in the Go standard library, search for [`go http listen`](https://sourcegraph.com/search?q=context:global+repo:%5Egithub%5C.com/golang/go%24+type:symbol+http+listen+select:symbol.function&patternType=lucky)

#### Search over history

Codebases are never static, you often need to understand what has changed over time. Is there an equivalent of `git log -p -S '$QUERY'` but across multiple repositories? Indeed, there is, as Sourcegraph indexes commit messages and diffs.

Here are a few interesting queries:

* [Search diffs, filtered by author "Linus Torvalds"](https://sourcegraph.com/search?q=context:global+type:diff+author:%22Linus+Torvalds%22&patternType=lucky)
* [Search commit messages, like which ones where Linus has fixed bugs](https://sourcegraph.com/search?q=context:global+type:commit+author:%22Linus+Torvalds%22+fix+bug&patternType=regexp)
* [Search multiple revisions](https://sourcegraph.com/search?q=context:global+repo:%5Egithub%5C.com/torvalds/linux%24%40master:v5.19:v5.18+Signal+.%2B+caused+a+tool+exit%2C+line+.%2B&patternType=regexp), which comes in handy when you have multiple active releases
* [Create a context](https://sourcegraph.com/contexts/new) to [search consistent revisions across many repositories](https://sourcegraph.com/search?q=context:global+repo:%5Egithub.com/gorilla/%40v1.0.0+test&patternType=lucky), which comes in handy if have multiple repositories that factor into a single release

#### Learn by example

A good example is worth a thousand words of documentation. Sourcegraph can show you usage examples pulled from across your organization and open source:

* See [the many different ways](https://sourcegraph.com/github.com/golang/go/-/blob/src/net/http/server.go?L86:6&subtree=true#tab=references) the `http.Handler` interface is used in the Go community. 
* See [implementations of the `http.Handler` interface](https://sourcegraph.com/github.com/golang/go/-/blob/src/net/http/server.go?L86:6&subtree=true#tab=implementations_go) across hundreds of third-party libraries.

Unlike any other tool, Sourcegraph can show you compiler-accurate references across *all the code*. These precise references are critical when chasing errors down the rabbithole of transitive dependencies. You can configure your codebase for precise code navigation by following [these docs](https://docs.sourcegraph.com/code_intelligence/explanations/precise_code_intelligence).

#### Search beyond regex

Code is filled with patterns involving balanced delimiters—parens for function calls, braces for blocks, quotes for strings. Regular expressions cannot express such patterns and that might explain why they are so often reviled, even while their use is ubiquitous.

In addition to regex, Sourcegraph supports an alternative pattern matching syntax called [Comby](https://comby.dev/) that was specifically designed for matching patterns in code while preserving the option to use regexes where needed. Here are a few examples:

* Find invocations of `fmt.Errorf` with exactly 2 arguments:
  * Comby: [`fmt.Errorf(":[_]", :[[_]])`](https://sourcegraph.com/search?q=context:global+fmt.Errorf%28%22:%5B_%5D%22%2C+:%5B%5B_%5D%5D%29+repo:%5Egithub.com/golang/&patternType=structural)
  * Regex: Not strictly possible. Approximation: [`fmt.Errorf\("[^"]+", \w+\)`](https://sourcegraph.com/search?q=context:global+fmt.Errorf%5C%28%22%5B%5E%22%5D%2B%22%2C+%5Cw%2B%5C%29+repo:%5Egithub.com/golang/&patternType=regexp)

* Find invocations of `malloc` within for loops:
  * Comby: [`for (:[_]) { :[_] malloc(:[_]) :[_] }`](https://sourcegraph.com/search?q=context:global+for+%28:%5B_%5D%29+%7B+:%5B_%5D+malloc%28:%5B_%5D%29+:%5B_%5D+%7D+repo:emscripten&patternType=structural)
  * Regex: Not strictly possible, it would be very messy

The [Comby syntax](https://comby.dev/docs/syntax-reference) is simple and straightforward and takes about 5 minutes to learn.

#### Track your train of thought...

Understanding code is often a winding, circuitous journey that involves branching, backtracking, and many instances of, "Wait, I've been here before, haven't I?" Because people often use Sourcegraph to make sense of some pretty gnarly code, we added a notepad to drop breadcrumbs and document your journey:

![](https://user-images.githubusercontent.com/1646931/184548842-db823aef-81cd-45d6-964a-64c47016cf4a.gif)

#### ...and share your understanding with others, turning notes into amazing docs

As you document your findings on your journey through code, you may realize that what you've learned will also be of value to others. With a single click, you can turn your notepad into a full-on interactive Markdown file with runnable search queries and code-nav-enabled code snippets.

Over time, these notebooks evolve into amazing docs that connect high-level prose explanations of architecture and design choices with concrete entryways into source:

![](https://user-images.githubusercontent.com/1646931/184758175-3cc4221d-b3c3-4422-8bed-e2beb94db18d.gif)

You can also incorporate these interactive search queries and code snippets into [READMEs versioned in your source repository](https://comby.dev/) simply by using the `.snb.md` file extension. And you can [embed them into external docsites and blogs](https://docs.sourcegraph.com/notebooks/notebook-embedding), too.

#### Find and address anti-patterns in your code, improving code quality

Another application of code search is surfacing anti-patterns, like code smells, accidentally committed secrets, and misinvocations of library packages.

In addition to a point-in-time snapshot of where these occur, you may also want to understand how things have changed over time. Sourcegraph makes that easy by allowing you to turn any seaerch query into a timeseries graph:

![](https://user-images.githubusercontent.com/1646931/184872434-9c8d3425-6d40-4af1-9d0a-3abd7e5a2b06.gif)

After you've located anti-patterns, you probably want to eliminate them. How do you do that?

There are many tools for executing refactors in code, but you often need to write a wrapping script to execute a change across many repositories. Sourcegraph can provide the scaffolding and execution engine to manage such large-scale changes and remediations.

#### Shepherd large-scale changes

Sourcegraph Batch Changes lets you shepherd a large-scale refactor with any code modification tool, from grep + sed to semantic tools (semgrep, etc):

![](https://user-images.githubusercontent.com/1646931/184923834-a31d444f-b234-4877-ad77-5403856c3e9d.gif)

Batch Changes can also be used for enterprise-wide remediation efforts. During the Log4j fallout, we wrote a [blog post](https://about.sourcegraph.com/blog/log4j-log4shell-0-day) documenting how our customers used Sourcegraph to quickly roll out patches with minimal disruption to their teams.

#### Enhance code review

Sourcegraph integrates with other dev tools, including editors and IDEs, but an often overlooked place where developers must read and understand code is the code review tool. By definition, such code is new and unfamiliar to the reviewer and can often be quite a chore to review.

Sourcegraph makes the process much easier by adding IDE-like code navigation to your review tool through our browser extension. Sourcegraph customers use this integration to enhance code reviews in GitHub, GitLab, Phabricator, Bitbucket, and Gerrit.

![](https://user-images.githubusercontent.com/1646931/184931140-77e9d4c3-86c6-4c93-a1b2-1e1ff06a8854.gif)

#### Explore your code as a dataset

TODO

#### Search from in your editor

TODO

### The road ahead

In the near term, we're focusing on scale and supporting customers with some of the largest, oldest, and most complex codebases in the world. Today, Sourcegraph indexes the code that powers the world's software infrastructure in sectors ranging from banking, healthcare, transportation, social media, and enterprise software.

In parallel, we will continue making open source code widely accessible to every dev and partnering with members of open-source communities on initiatives like these:

* Providing diffs for Rust's `cargo vet` CLI
* Creating [educational source-level walkthroughs](https://tourdesource.substack.com/) of projects like TypeScript ESLint, Caddy web server, and OpenVSCode Server
* Helping communities like Kubernetes, [Fedora](https://fedoramagazine.org/using-sourcegraph-to-search-34000-fedora-repositories/), and [Brave](http://code.brave.com/) use Sourcegraph
* Responding to questions and feature requests in our [community Discord](https://discord.gg/SSCBGByJeu)

#### Gatekeeper-less innovation

In the long run, Sourcegraph will democratize code understanding. Sourcegraph believes in an open, gatekeeper-less future for code. We believe in developer freedom of choice.

The early generations of software were founded atop proprietary platforms and vertically integrated walled gardens. But out of this emerged open standards and protocols that have enabled a Cambrian explosion of software innovation. This is why the web has grown to such prominence and why open source is now ubiquitous.

Adoption of dev tools should be driven by considerations of which tools are best-in-class, not by forced integration or vendor lock-in. Sourcegraph can play a role in ensuring market positions captured by code hosts and editors are not used to constrain developer choice. We already play this role inside many of our customers where Sourcegraph enables different teams to choose the best code host, code review, and editor that works for them.

The world is still figuring out how best to build software—the way read, write, run, and review code will look very different then years from now than it does today. Part of ensuring we keep pushing the frontier means enabling innovative new solutions to tackle different stages of the software development lifecycle, and to be adopted piecemeal without being locked into an existing vendor. The brightest future for software is neither closed or monolithic—it should be an open marketplace where upstarts and individual devs are free to create innovations without being captive to incumbent distribution channels. This vision sets us apart from many large dev tool and dev infrastructure companies driving toward greater bundling and vertical integration.

Sourcegraph can play a big role in preserving the choice of a diverse range of dev tools in your organization, while providing a common starting point—like a Google search bar—for understanding all the different tools, technologies, and code in your org.

We want the next generation of developers to grow up in a world that is open and even more accessible. It should be easy for newbies to peak under the hood into source code. It should be easy for new hires to onboard to their company's codebase. It should be easy for senior engineers and leaders to see how the code is evolving. Exploring code should be as seamless and delightful as surfing the web. If you find that vision compelling, [drop by our community Discord](https://discord.gg/SSCBGByJeu) and say hi!
