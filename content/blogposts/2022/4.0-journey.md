---
title: The road to 4.0 
description: TODO
authors:
  - name: Beyang Liu
    url: 
publishDate: 2022-09-27T00:00
tags: [blog]
slug: journey-to-four-oh
published: flase
<!-- heroImage: https://storage.googleapis.com/sourcegraph-assets/blog/jetbrains-plugin/jetbrains-announcement-hero.png -->
<!-- socialImage: https://storage.googleapis.com/sourcegraph-assets/blog/jetbrains-plugin/jetbrains-announcement-hero.png -->
---

Today Sourcegraph turns 4.0, a pivotal moment at which we serve over a million developers on teams ranging from early-stage startups to some of the most important institutions in the world. Here's a look back at the journey so far.

### Genesis

There was no single "eureka" moment. But the catalyzing experience for me was working as a dev at Palantir with Quinn. On my first day, I inherited an application that had had 5 owners in the previous 12 months. Each seemingly simple fix involved a long string of "why"s and "wat"s.

A month into the job, I had made a handful of minor fixes. I was meeting expectations, but something felt off.
I'd gotten into programming because I fell in love with *that feeling*. The feeling of solving tricky puzzles to make something cool. The feeling when you hit enter and the code comes to life. The feeling you experience when you're coding at the speed of thought.
And here I was, first month into my professional programming career, and I'd gone an entire month without experiencing that feeling!

I'd spent nearly all my time trying to understand existing code. And it dawned on me that most of my job was not writing code, but reading it. The problem was that reading code was a lot less fun than writing it!

A couple years later, Quinn and I got to reflecting on our journey as programmers and we discovered a mutual yearning for more of those magical moments when you get to experience *the feeling*.
Sourcegraph crystallized around those discussions. Code search was a starting point of inspiration for both of us, Quinn having spun up OpenGrok to make sense of large open-source codebases and me having used code search inside Google. We both realized that search was a powerful tool that could make large codebases tractable by making reading code more fun and efficient.

But we dreamt of something more--a big intelligent system that had the brain of an IDE but awareness of all the code in the world.
A global graph that understood every symbol and reference in the world, that pulled in context from monitoring systems, static analyzers, security scanners, and more, and overlaid this information, along with j2d and xrefs, into every place you read code.
Such a system would democratize access to code, eliminating the gatekeepers that lie on the critical path to acquiring fluency in code.

### Early iterations

Being over-confident engineers, we estimated it would take us about 3 months to build such a system.

The MVP of Sourcegraph was an Angular app. You could search for symbols by name, and we had jump-to-def and xrefs for a few languages provided by [srclib](https://srclib.org).

Sourcegraph 1 was a server-side rendered application with minimal JS restricted mostly to the code-browsing interface. We thought we should be more of a snappy content site and we had a page dedicated to rendering docs.

Sourcegraph 2 was React and TypeScript, pivoting back to a rich web app experience. We adopted a multi-service architecture for scale, deployed via either Kubernetes or a single Docker container.

### Inflection point

In February of 2019, we announced [Sourcegraph 3.0](https://about.sourcegraph.com/blog/sourcegraph-3.0) and open-sourced our core code.
Then things really picked up. The open core model enabled us to address security concerns and earn developer trust, and the single Docker container enabled any dev to spin up an instance on their local machine, add some private code, and see Sourcegraph in action.

We adopted a layered approach to code navigation that allowed us to support a much wider set of languages.
We supported repository permissions for all major code hosts, something that was critical to enterprises.

Since 3.0, we've shipped so many more things.
* We listened to our customers undertaking large refactors to improve security, code quality, and code reuse, and we created Batch Changes to shepherd such big changesets to completion.
* We listened to our customers using search queries to detect and track patterns and anti-patterns, such as accidentally committed secrets and adoption of new APIs. We created Code Insights to turn any such query into a timeseries graph, embeddable in a dashboard.
* We also made it possible to create code monitors to alert on these queries.
* We saw many of our users recording their explorations into code using text files, so we created Notebooks to record and transform those notes into a rich, shareable Markdown doc with embeddable queries and code snippets.
* We've enriched our search query language to encompass much more than regexâ€”a plethora of filters and selectors searching over raw code, symbols, diffs, and metadata, along with support for the Comby syntax that makes matching common code patterns far more ergonomic than regex.
* We've expanded precise code navigation to Go, TypeScript, JavaScript, C++, Java, Scala, Kotlin, and Python, and we now support auto-indexing to automatically generate this information without need for extra configuration.
* We've indexed more than 3 million open source repositories, including nearly every GitHub repository with more than 5 stars, code hosted on other code hosts such as GitLab and standalone source repositories, and code in common package hosts like NPM, PyPI, and Maven Central.

### Sourcegraph today

